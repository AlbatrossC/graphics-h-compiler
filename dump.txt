
================================================================================
FILE: VScodeExtension/src\compiler.ts
================================================================================

import * as vscode from 'vscode';
import * as path from 'path';
import { spawn, ChildProcess } from 'child_process';
import { PathManager } from './paths';
import * as fs from 'fs';

interface CompilationError {
    file: string;
    line: number;
    column: number;
    severity: 'error' | 'warning';
    message: string;
}

export class GraphicsCompiler {
    private pathManager: PathManager;
    private outputChannel: vscode.OutputChannel;
    private activeProcesses: Set<ChildProcess> = new Set();
    private diagnosticCollection: vscode.DiagnosticCollection;
    private runningProgram: ChildProcess | null = null;

    constructor(pathManager: PathManager) {
        this.pathManager = pathManager;
        this.outputChannel = vscode.window.createOutputChannel('Graphics.h Compiler');
        this.diagnosticCollection = vscode.languages.createDiagnosticCollection('graphics-h');
    }

    // Get user configuration settings
    private getConfig() {
        const config = vscode.workspace.getConfiguration('graphics-h-compiler');
        return {
            autoRun: config.get<boolean>('autoRun', true),
            showOutput: config.get<boolean>('showOutputPanel', true),
            clearOutputBeforeCompile: config.get<boolean>('clearOutputBeforeCompile', true)
        };
    }

    // Validate source file path for security
    private validateSourceFile(sourceFile: string): boolean {
        const normalizedPath = path.normalize(sourceFile);
        
        if (normalizedPath.includes('..')) {
            vscode.window.showErrorMessage('Invalid file path: Path traversal detected');
            return false;
        }

        if (!fs.existsSync(normalizedPath)) {
            vscode.window.showErrorMessage('Source file does not exist');
            return false;
        }

        const stats = fs.statSync(normalizedPath);
        if (!stats.isFile()) {
            vscode.window.showErrorMessage('Path is not a file');
            return false;
        }

        if (!normalizedPath.endsWith('.cpp') && !normalizedPath.endsWith('.c++')) {
            vscode.window.showErrorMessage('File must be a C++ source file (.cpp or .c++)');
            return false;
        }

        return true;
    }

    // Parse GCC/G++ error messages
    private parseCompilerErrors(stderr: string, sourceFile: string): CompilationError[] {
        const errors: CompilationError[] = [];
        const errorRegex = /^(.+?):(\d+):(\d+):\s+(error|warning):\s+(.+)$/gm;
        
        let match;
        while ((match = errorRegex.exec(stderr)) !== null) {
            const [_, file, line, column, severity, message] = match;
            
            errors.push({
                file: file.trim(),
                line: parseInt(line, 10),
                column: parseInt(column, 10),
                severity: severity as 'error' | 'warning',
                message: message.trim()
            });
        }

        return errors;
    }

    // Update VS Code diagnostics panel
    private updateDiagnostics(errors: CompilationError[], sourceFile: string): void {
        const diagnostics: vscode.Diagnostic[] = [];
        const uri = vscode.Uri.file(sourceFile);

        for (const error of errors) {
            const line = Math.max(0, error.line - 1);
            const column = Math.max(0, error.column - 1);
            
            const range = new vscode.Range(
                new vscode.Position(line, column),
                new vscode.Position(line, column + 100)
            );

            const diagnostic = new vscode.Diagnostic(
                range,
                error.message,
                error.severity === 'error' 
                    ? vscode.DiagnosticSeverity.Error 
                    : vscode.DiagnosticSeverity.Warning
            );

            diagnostic.source = 'graphics-h-compiler';
            diagnostics.push(diagnostic);
        }

        this.diagnosticCollection.set(uri, diagnostics);
    }

    // Clear diagnostics
    private clearDiagnostics(sourceFile: string): void {
        const uri = vscode.Uri.file(sourceFile);
        this.diagnosticCollection.delete(uri);
    }

    // Compile C++ source file
    async compile(sourceFile: string, token?: vscode.CancellationToken): Promise<string | null> {
        if (!this.validateSourceFile(sourceFile)) {
            return null;
        }

        const config = this.getConfig();
        const gppPath = this.pathManager.getGppPath();
        const graphicsPath = this.pathManager.getGraphicsPath();
        const libraryPath = this.pathManager.getLibraryPath();
        const outputPath = this.pathManager.getOutputPath(sourceFile);

        this.clearDiagnostics(sourceFile);

        if (config.clearOutputBeforeCompile) {
            this.outputChannel.clear();
        }
        
        if (config.showOutput) {
            this.outputChannel.show(true);
        }

        this.outputChannel.appendLine(`[graphics-h] OS: Windows`);
        this.outputChannel.appendLine(`[graphics-h] Compiling: ${path.basename(sourceFile)}`);
        this.outputChannel.appendLine(`[graphics-h] Output: ${path.basename(outputPath)}`);
        this.outputChannel.appendLine('');

        return new Promise((resolve) => {
            const startTime = Date.now();

            // Prepare compiler arguments
            const command = gppPath;
            const args = [
                sourceFile,
                '-I', graphicsPath,
                '-L', libraryPath,
                '-lbgi', '-lgdi32', '-lcomdlg32', '-luuid', '-loleaut32', '-lole32',
                '-o', outputPath
            ];

            const compilerProcess = spawn(command, args, {
                cwd: path.dirname(sourceFile)
            });

            this.activeProcesses.add(compilerProcess);

            let stderr = '';
            let stdout = '';

            compilerProcess.stdout.on('data', (data) => {
                stdout += data.toString();
            });

            compilerProcess.stderr.on('data', (data) => {
                const output = data.toString();
                stderr += output;
                this.outputChannel.append(output);
            });

            token?.onCancellationRequested(() => {
                if (!compilerProcess.killed) {
                    compilerProcess.kill();
                    this.outputChannel.appendLine('');
                    this.outputChannel.appendLine('[graphics-h] Compilation cancelled by user');
                    this.activeProcesses.delete(compilerProcess);
                    resolve(null);
                }
            });

            compilerProcess.on('close', (code) => {
                const duration = ((Date.now() - startTime) / 1000).toFixed(2);
                this.activeProcesses.delete(compilerProcess);

                if (code !== 0) {
                    if (stderr.trim().length === 0) {
                        this.outputChannel.appendLine('error: compilation failed with no error output');
                    }
                    
                    this.outputChannel.appendLine('');
                    this.outputChannel.appendLine(`[graphics-h] ‚úó Build failed (${duration}s)`);
                    
                    const errors = this.parseCompilerErrors(stderr, sourceFile);
                    this.updateDiagnostics(errors, sourceFile);

                    const errorCount = errors.filter(e => e.severity === 'error').length;
                    const warningCount = errors.filter(e => e.severity === 'warning').length;
                    
                    let message = `Compilation failed: ${errorCount} error${errorCount !== 1 ? 's' : ''}`;
                    if (warningCount > 0) {
                        message += `, ${warningCount} warning${warningCount !== 1 ? 's' : ''}`;
                    }

                    vscode.window.showErrorMessage(
                        message,
                        'Show Output',
                        'Show Problems'
                    ).then(choice => {
                        if (choice === 'Show Output') {
                            this.outputChannel.show();
                        } else if (choice === 'Show Problems') {
                            vscode.commands.executeCommand('workbench.actions.view.problems');
                        }
                    });
                    
                    resolve(null);
                } else {
                    this.outputChannel.appendLine(`[graphics-h] ‚úì Build succeeded (${duration}s)`);
                    this.outputChannel.appendLine(`[graphics-h] Executable: ${path.basename(outputPath)}`);
                    
                    resolve(outputPath);
                }
            });

            compilerProcess.on('error', (error) => {
                this.outputChannel.appendLine('');
                this.outputChannel.appendLine(`[graphics-h] Compiler error: ${error.message}`);
                
                this.activeProcesses.delete(compilerProcess);
                
                vscode.window.showErrorMessage(
                    `Compiler error: ${error.message}`,
                    'Show Output'
                ).then(choice => {
                    if (choice === 'Show Output') {
                        this.outputChannel.show();
                    }
                });
                
                resolve(null);
            });
        });
    }

    // Run compiled executable
    async run(exePath: string): Promise<void> {
        if (!fs.existsSync(exePath)) {
            vscode.window.showErrorMessage('Executable not found: ' + exePath);
            return;
        }

        this.outputChannel.appendLine(`[graphics-h] Running: ${path.basename(exePath)}`);
        this.outputChannel.appendLine('');

        const programProcess = spawn(exePath, [], {
            cwd: path.dirname(exePath),
            detached: false,
            stdio: ['ignore', 'pipe', 'pipe']
        });

        this.runningProgram = programProcess;

        programProcess.stdout.on('data', (data) => {
            this.outputChannel.append(`[Program Output] ${data.toString()}`);
        });

        programProcess.stderr.on('data', (data) => {
            this.outputChannel.append(`[Program Error] ${data.toString()}`);
        });

        programProcess.on('close', (code) => {
            this.runningProgram = null;
            this.outputChannel.appendLine('');
            if (code === 0) {
                this.outputChannel.appendLine(`[graphics-h] ‚úì Program finished successfully`);
            } else if (code !== null) {
                this.outputChannel.appendLine(`[graphics-h] ‚úó Program exited with code ${code}`);
            } else {
                this.outputChannel.appendLine(`[graphics-h] Program stopped`);
            }
        });

        programProcess.on('error', (error) => {
            this.runningProgram = null;
            this.outputChannel.appendLine('');
            this.outputChannel.appendLine('[graphics-h] Program execution failed:');
            this.outputChannel.appendLine(error.message);
            
            vscode.window.showErrorMessage('Failed to run program. Check Output panel.');
        });

        programProcess.on('exit', (code, signal) => {
            if (signal) {
                this.outputChannel.appendLine(`[graphics-h] Program terminated by signal: ${signal}`);
            }
        });
    }

    // Stop currently running program
    stopRunningProgram(): boolean {
        if (this.runningProgram && !this.runningProgram.killed) {
            this.outputChannel.appendLine('[graphics-h] Stopping program...');
            this.runningProgram.kill();
            this.runningProgram = null;
            return true;
        }
        return false;
    }

    // Check if program is running
    isProgramRunning(): boolean {
        return this.runningProgram !== null && !this.runningProgram.killed;
    }

    // Compile and run in sequence
    async compileAndRun(sourceFile: string): Promise<void> {
        const config = this.getConfig();
        
        if (this.isProgramRunning()) {
            this.stopRunningProgram();
        }

        const exePath = await this.compile(sourceFile);
        
        if (exePath && config.autoRun) {
            await this.run(exePath);
        } else if (exePath && !config.autoRun) {
            const choice = await vscode.window.showInformationMessage(
                'Compilation successful',
                'Run Program'
            );
            if (choice === 'Run Program') {
                await this.run(exePath);
            }
        }
    }

    // Dispose of resources
    dispose(): void {
        this.diagnosticCollection.clear();
        this.diagnosticCollection.dispose();
        this.outputChannel.dispose();

        if (this.runningProgram && !this.runningProgram.killed) {
            this.runningProgram.kill();
        }

        this.activeProcesses.forEach(proc => {
            if (!proc.killed) {
                proc.kill();
            }
        });
        this.activeProcesses.clear();
    }
}


================================================================================
FILE: VScodeExtension/src\extension.ts
================================================================================

import * as vscode from 'vscode';
import { PathManager, OperatingSystem } from './paths';
import { WindowsDownloader } from './windowsDownloader';
import { GraphicsCompiler } from './compiler';

let pathManager: PathManager;
let windowsDownloader: WindowsDownloader | null = null;
let compiler: GraphicsCompiler;
let statusBarItem: vscode.StatusBarItem;

export function activate(context: vscode.ExtensionContext) {
    console.log('Graphics.h Compiler extension activated');

    // Initialize core managers
    pathManager = new PathManager(context);
    const currentOS = pathManager.getOS();
    
    // Initialize Windows downloader
    if (currentOS === OperatingSystem.Windows) {
        windowsDownloader = new WindowsDownloader();
    }
    
    compiler = new GraphicsCompiler(pathManager);

    // Show OS detection info
    const osName = pathManager.getOSDisplayName();
    console.log(`Detected OS: ${osName}`);

    // Check for unsupported OS
    if (currentOS !== OperatingSystem.Windows) {
        vscode.window.showErrorMessage(
            'Graphics.h Compiler: This extension only works on Windows.',
            'OK'
        );
        return;
    }

    // Display welcome message on first activation
    const hasShownWelcome = context.globalState.get<boolean>('graphics-h.welcomeShown', false);
    if (!hasShownWelcome) {
        showWelcomeMessage(context);
        context.globalState.update('graphics-h.welcomeShown', true);
    }

    // Create status bar button
    statusBarItem = vscode.window.createStatusBarItem(
        vscode.StatusBarAlignment.Right,
        100
    );
    statusBarItem.command = 'graphics-h-compiler.compileAndRun';
    context.subscriptions.push(statusBarItem);

    // Update status bar
    context.subscriptions.push(
        vscode.window.onDidChangeActiveTextEditor(updateStatusBar)
    );
    updateStatusBar(vscode.window.activeTextEditor);

    // Register commands
    context.subscriptions.push(
        vscode.commands.registerCommand(
            'graphics-h-compiler.compileAndRun',
            handleCompileAndRun
        )
    );

    context.subscriptions.push(
        vscode.commands.registerCommand(
            'graphics-h-compiler.compileOnly',
            handleCompileOnly
        )
    );

    context.subscriptions.push(
        vscode.commands.registerCommand(
            'graphics-h-compiler.setupToolchain',
            handleSetupToolchain
        )
    );

    context.subscriptions.push(
        vscode.commands.registerCommand(
            'graphics-h-compiler.stopProgram',
            handleStopProgram
        )
    );

    context.subscriptions.push(
        vscode.commands.registerCommand(
            'graphics-h-compiler.checkDependencies',
            handleCheckDependencies
        )
    );

    // Register cleanup
    context.subscriptions.push({
        dispose: () => {
            if (compiler) {
                compiler.dispose();
            }
        }
    });

    // Check dependencies quietly
    checkDependenciesQuietly();
}

// Show welcome message
function showWelcomeMessage(context: vscode.ExtensionContext): void {
    const message = 'Graphics.h Compiler activated! Ready to compile and run graphics programs.';

    vscode.window.showInformationMessage(
        message,
        'Check Dependencies',
        'Dismiss'
    ).then(choice => {
        if (choice === 'Check Dependencies') {
            handleCheckDependencies();
        }
    });
}

// Update status bar
function updateStatusBar(editor: vscode.TextEditor | undefined): void {
    if (editor && editor.document.languageId === 'cpp') {
        if (compiler && compiler.isProgramRunning()) {
            statusBarItem.text = '$(debug-stop) Stop Graphics';
            statusBarItem.tooltip = 'Stop Running Graphics Program';
            statusBarItem.command = 'graphics-h-compiler.stopProgram';
        } else {
            statusBarItem.text = '$(play) Run Graphics';
            statusBarItem.tooltip = 'Compile & Run Graphics Program (Ctrl+Alt+N)';
            statusBarItem.command = 'graphics-h-compiler.compileAndRun';
        }
        statusBarItem.show();
    } else {
        statusBarItem.hide();
    }
}

// Periodically update status bar
setInterval(() => {
    updateStatusBar(vscode.window.activeTextEditor);
}, 1000);

// Quiet dependency check - just verifies, doesn't install
async function checkDependenciesQuietly(): Promise<void> {
    const missing = pathManager.getMissingDependencies();
    
    if (missing.length > 0) {
        console.log('Graphics.h dependencies not installed:', missing.join(', '));
        console.log('User will be prompted when they try to compile.');
    } else {
        console.log('Graphics.h toolchain is ready');
    }
}

// Check and display dependency status
async function handleCheckDependencies(): Promise<void> {
    const missing = pathManager.getMissingDependencies();
    const required = pathManager.getRequiredDependencies();
    const osName = pathManager.getOSDisplayName();

    if (missing.length === 0) {
        vscode.window.showInformationMessage(
            `‚úì All dependencies are installed!\n\n` +
            `Platform: ${osName}\n` +
            `Required: ${required.join(', ')}`
        );
        return;
    }

    const message = 
        `‚ö†Ô∏è Missing dependencies on ${osName}:\n\n` +
        `Missing: ${missing.join(', ')}\n\n` +
        `Required: ${required.join(', ')}\n\n` +
        `Would you like to install the missing dependencies now?`;

    const choice = await vscode.window.showWarningMessage(
        message,
        { modal: true },
        'Install Now',
        'Cancel'
    );

    if (choice === 'Install Now') {
        await handleSetupToolchain();
    }
}

// Wait for toolchain and ask permission if needed
async function waitForToolchain(): Promise<boolean> {
    const missing = pathManager.getMissingDependencies();
    
    if (missing.length === 0) {
        return true;
    }

    // Check if installation is in progress
    const isInProgress = windowsDownloader?.isInProgress() ?? false;

    if (isInProgress) {
        vscode.window.showInformationMessage(
            '‚è≥ Toolchain installation is already in progress. Please wait...'
        );
        return false;
    }

    // Toolchain not installed - ask user for permission
    const hasPermission = await windowsDownloader!.promptForPermission();
    
    if (!hasPermission) {
        vscode.window.showInformationMessage(
            '‚ÑπÔ∏è Graphics.h toolchain is required to compile programs.\n\n' +
            'You can install it anytime using:\n' +
            'Command Palette (Ctrl+Shift+P) ‚Üí "Graphics.h: Setup Graphics.h Toolchain"',
            'OK'
        );
        return false;
    }

    // User gave permission - start installation
    const targetPath = pathManager.getToolchainPath();
    return await windowsDownloader!.download(targetPath, pathManager.getExtensionPath());
}

// Handle compile and run
async function handleCompileAndRun(): Promise<void> {
    try {
        const ready = await waitForToolchain();
        if (!ready) {
            return;
        }

        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage('No file is currently open');
            return;
        }

        const filePath = editor.document.uri.fsPath;

        if (!filePath.endsWith('.cpp') && !filePath.endsWith('.c++')) {
            vscode.window.showErrorMessage('Current file is not a C++ file (.cpp or .c++)');
            return;
        }

        if (editor.document.isDirty) {
            const saved = await editor.document.save();
            if (!saved) {
                vscode.window.showErrorMessage('Failed to save file. Please save manually and try again.');
                return;
            }
        }

        await compiler.compileAndRun(filePath);
        updateStatusBar(editor);

    } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        vscode.window.showErrorMessage(`Compilation failed: ${errorMsg}`);
        console.error('Compilation error:', error);
    }
}

// Handle compile only
async function handleCompileOnly(): Promise<void> {
    try {
        const ready = await waitForToolchain();
        if (!ready) {
            return;
        }

        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage('No file is currently open');
            return;
        }

        const filePath = editor.document.uri.fsPath;

        if (!filePath.endsWith('.cpp') && !filePath.endsWith('.c++')) {
            vscode.window.showErrorMessage('Current file is not a C++ file (.cpp or .c++)');
            return;
        }

        if (editor.document.isDirty) {
            const saved = await editor.document.save();
            if (!saved) {
                vscode.window.showErrorMessage('Failed to save file. Please save manually and try again.');
                return;
            }
        }

        await compiler.compile(filePath);

    } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        vscode.window.showErrorMessage(`Compilation failed: ${errorMsg}`);
        console.error('Compilation error:', error);
    }
}

// Handle manual setup
async function handleSetupToolchain(): Promise<boolean> {
    try {
        const missing = pathManager.getMissingDependencies();
        const osName = pathManager.getOSDisplayName();

        if (missing.length === 0) {
            const choice = await vscode.window.showWarningMessage(
                `All dependencies are already installed on ${osName}. Do you want to reinstall?`,
                { modal: true },
                'Reinstall',
                'Cancel'
            );

            if (choice !== 'Reinstall') {
                return true;
            }
        }

        // Ask for permission
        const hasPermission = await windowsDownloader!.promptForPermission();
            
        if (!hasPermission) {
            return false;
        }

        const targetPath = pathManager.getToolchainPath();
        return await windowsDownloader!.download(targetPath, pathManager.getExtensionPath());

    } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        vscode.window.showErrorMessage(`Setup failed: ${errorMsg}`);
        console.error('Setup error:', error);
        return false;
    }
}

// Handle stop program
async function handleStopProgram(): Promise<void> {
    if (compiler && compiler.isProgramRunning()) {
        const stopped = compiler.stopRunningProgram();
        if (stopped) {
            vscode.window.showInformationMessage('Graphics program stopped');
            updateStatusBar(vscode.window.activeTextEditor);
        }
    } else {
        vscode.window.showInformationMessage('No graphics program is currently running');
    }
}

export function deactivate() {
    if (statusBarItem) {
        statusBarItem.dispose();
    }

    if (compiler) {
        compiler.dispose();
    }

    console.log('Graphics.h Compiler extension deactivated');
}


================================================================================
FILE: VScodeExtension/src\paths.ts
================================================================================

import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import * as os from 'os';

export enum OperatingSystem {
    Windows = 'windows',
    Unknown = 'unknown'
}

export class PathManager {
    private context: vscode.ExtensionContext;
    private currentOS: OperatingSystem;

    constructor(context: vscode.ExtensionContext) {
        this.context = context;
        this.currentOS = this.detectOS();
    }

    // Detect the current operating system
    private detectOS(): OperatingSystem {
        const platform = os.platform();
        
        if (platform === 'win32') {
            return OperatingSystem.Windows;
        }
        
        return OperatingSystem.Unknown;
    }

    // Get current OS
    getOS(): OperatingSystem {
        return this.currentOS;
    }

    // Get extension installation path
    getExtensionPath(): string {
        return this.context.extensionPath;
    }

    // Check if running on Windows
    isWindows(): boolean {
        return this.currentOS === OperatingSystem.Windows;
    }

    // Get toolchain installation directory in VS Code global storage
    getToolchainPath(): string {
        // Store MinGW32
        return path.join(this.context.globalStorageUri.fsPath, 'mingw32');
    }

    // Get path to bundled graphics libraries
    getGraphicsPath(): string {
        const mingwPath = this.getToolchainPath();
        return path.join(mingwPath, 'include');
    }

    // Get path to libbgi.a
    getLibraryPath(): string {
        const mingwPath = this.getToolchainPath();
        return path.join(mingwPath, 'lib');
    }

    // Get path to g++ compiler executable
    getGppPath(): string {
        const mingwPath = this.getToolchainPath();
        return path.join(mingwPath, 'bin', 'g++.exe');
    }

    // Check if toolchain is installed
    isToolchainInstalled(): boolean {
        // Check if MinGW g++.exe exists
        return fs.existsSync(this.getGppPath());
    }

    // Check if all required dependencies are installed
    areAllDependenciesInstalled(): boolean {
        return this.isToolchainInstalled();
    }

    // Get output executable path for a source file
    getOutputPath(sourceFile: string): string {
        const dir = path.dirname(sourceFile);
        const name = path.basename(sourceFile, path.extname(sourceFile));
        return path.join(dir, `${name}.exe`);
    }

    // Get human-readable OS name
    getOSDisplayName(): string {
        switch (this.currentOS) {
            case OperatingSystem.Windows:
                return 'Windows';
            default:
                return 'Unknown';
        }
    }

    // Get required dependencies based on OS
    getRequiredDependencies(): string[] {
        return ['MinGW32 Toolchain (C++ Compiler + Libraries)'];
    }

    // Check for missing dependencies
    getMissingDependencies(): string[] {
        const missing: string[] = [];
        
        if (!this.isToolchainInstalled()) {
            missing.push('MinGW32 Toolchain');
        }
        
        return missing;
    }
}


================================================================================
FILE: VScodeExtension/src\windowsDownloader.ts
================================================================================

import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import * as crypto from 'crypto';
import fetch from 'node-fetch';
import AdmZip from 'adm-zip';

interface DownloadConfig {
    url: string;
    sha256?: string;
    fallbackUrls?: string[];
}

export class WindowsDownloader {
    private isDownloading = false;
    private downloadPromise: Promise<boolean> | null = null;

    // Configuration for MinGW download
    private readonly MINGW_CONFIG: DownloadConfig = {
        url: 'https://www.dropbox.com/scl/fi/82j3vrao5my1w8amee44v/mingw32.zip?rlkey=0issjauibhxolr3iiypc5qpjc&e=2&st=x6obvlyq&dl=1',
        sha256: '',
        fallbackUrls: []
    };

    isInProgress(): boolean {
        return this.isDownloading;
    }

    // Verify downloaded file integrity using SHA256
    private async verifyDownload(filePath: string, expectedHash: string): Promise<boolean> {
        if (!expectedHash) {
            return true;
        }

        try {
            const fileBuffer = fs.readFileSync(filePath);
            const hashSum = crypto.createHash('sha256');
            hashSum.update(fileBuffer);
            const actualHash = hashSum.digest('hex').toLowerCase();
            const expected = expectedHash.toLowerCase();

            if (actualHash !== expected) {
                console.error('Hash mismatch:');
                console.error('  Expected:', expected);
                console.error('  Actual:  ', actualHash);
                return false;
            }

            return true;
        } catch (error) {
            console.error('Error verifying download:', error);
            return false;
        }
    }

    // Download from URL with fallback support
    private async downloadFromUrl(
        url: string,
        tempZip: string,
        progress: vscode.Progress<{ message?: string; increment?: number }>
    ): Promise<boolean> {
        try {
            progress.report({ 
                message: `Downloading MinGW32 toolchain...`,
                increment: 5
            });

            const response = await fetch(url, {
                headers: { 
                    'User-Agent': 'Mozilla/5.0',
                    'Accept': 'application/octet-stream'
                },
                redirect: 'follow'
            });

            if (!response.ok) {
                throw new Error(`Download failed: HTTP ${response.status} ${response.statusText}`);
            }

            const totalSize = parseInt(response.headers.get('content-length') || '0');
            
            if (totalSize === 0) {
                throw new Error('Could not determine file size');
            }

            await this.streamToDisk(response, tempZip, progress, totalSize);

            if (this.MINGW_CONFIG.sha256) {
                progress.report({ 
                    message: `Verifying integrity...`,
                    increment: 5
                });

                const isValid = await this.verifyDownload(tempZip, this.MINGW_CONFIG.sha256);
                if (!isValid) {
                    throw new Error(`Verification failed: Checksum mismatch`);
                }
            }

            return true;

        } catch (error) {
            const errorMsg = error instanceof Error ? error.message : String(error);
            console.error(`Download from ${url} failed:`, errorMsg);
            throw error;
        }
    }

    // Stream download directly to disk
    private async streamToDisk(
        response: any,
        filePath: string,
        progress: vscode.Progress<{ message?: string; increment?: number }>,
        totalSize: number
    ): Promise<void> {
        return new Promise((resolve, reject) => {
            const fileStream = fs.createWriteStream(filePath);
            let downloadedSize = 0;
            let lastReportedPercent = 0;

            response.body.on('data', (chunk: Buffer) => {
                downloadedSize += chunk.length;
                const percent = Math.floor((downloadedSize / totalSize) * 100);
                
                if (percent >= lastReportedPercent + 5) {
                    const sizeMB = (downloadedSize / 1024 / 1024).toFixed(1);
                    const totalMB = (totalSize / 1024 / 1024).toFixed(1);
                    
                    progress.report({
                        message: `Downloading: ${sizeMB}MB / ${totalMB}MB (${percent}%)`,
                        increment: 5
                    });
                    
                    lastReportedPercent = percent;
                }
            });

            response.body.pipe(fileStream);

            fileStream.on('finish', () => {
                fileStream.close();
                resolve();
            });

            fileStream.on('error', (error: Error) => {
                fileStream.close();
                if (fs.existsSync(filePath)) {
                    try {
                        fs.unlinkSync(filePath);
                    } catch (cleanupError) {
                        console.error('Failed to cleanup partial file:', cleanupError);
                    }
                }
                reject(error);
            });

            response.body.on('error', (error: Error) => {
                fileStream.close();
                if (fs.existsSync(filePath)) {
                    try {
                        fs.unlinkSync(filePath);
                    } catch (cleanupError) {
                        console.error('Failed to cleanup partial file:', cleanupError);
                    }
                }
                reject(error);
            });
        });
    }

    // Copy bundled graphics files to MinGW directories
    private copyBundledGraphicsFiles(
        mingwPath: string,
        extensionPath: string,
        progress: vscode.Progress<{ message?: string; increment?: number }>
    ): void {
        progress.report({
            message: "Installing graphics.h files...",
            increment: 5
        });

        const resourcesPath = path.join(extensionPath, 'resources', 'graphics');
        const includeDir = path.join(mingwPath, 'include');
        const libDir = path.join(mingwPath, 'lib');

        const files = [
            { name: 'graphics.h', targetDir: includeDir },
            { name: 'winbgim.h', targetDir: includeDir },
            { name: 'libbgi.a', targetDir: libDir }
        ];

        for (const file of files) {
            const sourceFile = path.join(resourcesPath, file.name);
            const targetFile = path.join(file.targetDir, file.name);

            if (!fs.existsSync(sourceFile)) {
                throw new Error(`Bundled file ${file.name} not found in extension resources`);
            }

            // Create target directory if it doesn't exist
            if (!fs.existsSync(file.targetDir)) {
                fs.mkdirSync(file.targetDir, { recursive: true });
            }

            fs.copyFileSync(sourceFile, targetFile);

            if (!fs.existsSync(targetFile)) {
                throw new Error(`Failed to copy ${file.name} to MinGW directory`);
            }
        }

        progress.report({
            message: "‚úì Graphics.h files installed",
            increment: 5
        });
    }

    // Main download and installation function for Windows
    async download(targetPath: string, extensionPath: string): Promise<boolean> {
        if (this.downloadPromise) {
            return this.downloadPromise;
        }

        this.isDownloading = true;

        this.downloadPromise = new Promise<boolean>((resolve) => {
            vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: "Graphics.h Toolchain Setup (Windows)",
                cancellable: false
            }, async (progress) => {
                const tempZip = path.join(targetPath, 'mingw32_temp.zip');

                try {
                    // Create target directory
                    progress.report({ 
                        message: "Preparing installation...",
                        increment: 5
                    });
                    
                    if (!fs.existsSync(targetPath)) {
                        fs.mkdirSync(targetPath, { recursive: true });
                    }

                    // Download MinGW32
                    const urlsToTry = [
                        this.MINGW_CONFIG.url,
                        ...(this.MINGW_CONFIG.fallbackUrls || [])
                    ];

                    let downloadSuccess = false;
                    let lastError: Error | null = null;

                    for (const url of urlsToTry) {
                        if (!url) continue;

                        try {
                            await this.downloadFromUrl(url, tempZip, progress);
                            downloadSuccess = true;
                            break;
                        } catch (error) {
                            lastError = error instanceof Error ? error : new Error(String(error));
                            
                            if (fs.existsSync(tempZip)) {
                                try {
                                    fs.unlinkSync(tempZip);
                                } catch (cleanupError) {
                                    console.error('Failed to delete partial zip:', cleanupError);
                                }
                            }

                            if (url !== urlsToTry[urlsToTry.length - 1]) {
                                console.log(`Trying fallback URL...`);
                                continue;
                            }
                        }
                    }

                    if (!downloadSuccess) {
                        throw lastError || new Error('All download URLs failed');
                    }

                    // Extract MinGW32
                    progress.report({ 
                        message: "Extracting MinGW32 toolchain...",
                        increment: 30
                    });

                    const zip = new AdmZip(tempZip);
                    zip.extractAllTo(path.dirname(targetPath), true);

                    // Clean up zip file
                    if (fs.existsSync(tempZip)) {
                        fs.unlinkSync(tempZip);
                    }

                    // Copy bundled graphics.h files
                    this.copyBundledGraphicsFiles(targetPath, extensionPath, progress);

                    // Verify installation
                    progress.report({ 
                        message: "Verifying installation...",
                        increment: 10
                    });

                    const gppPath = path.join(targetPath, 'bin', 'g++.exe');
                    if (!fs.existsSync(gppPath)) {
                        throw new Error('MinGW installation verification failed');
                    }

                    progress.report({ 
                        message: "Complete!",
                        increment: 5
                    });

                    vscode.window.showInformationMessage('‚úì Graphics.h toolchain installed successfully!');

                    this.isDownloading = false;
                    this.downloadPromise = null;
                    resolve(true);

                } catch (error) {
                    this.isDownloading = false;
                    this.downloadPromise = null;

                    if (fs.existsSync(tempZip)) {
                        try {
                            fs.unlinkSync(tempZip);
                        } catch (cleanupError) {
                            console.error('Failed to delete partial zip:', cleanupError);
                        }
                    }

                    const errorMsg = error instanceof Error ? error.message : String(error);
                    
                    vscode.window.showErrorMessage(
                        `Toolchain setup failed: ${errorMsg}`,
                        'Retry',
                        'Report Issue'
                    ).then(choice => {
                        if (choice === 'Retry') {
                            this.downloadPromise = null;
                            this.download(targetPath, extensionPath);
                        } else if (choice === 'Report Issue') {
                            vscode.env.openExternal(
                                vscode.Uri.parse('https://github.com/YOUR_USERNAME/YOUR_REPO/issues')
                            );
                        }
                    });

                    console.error('Installation error:', error);
                    resolve(false);
                }
            });
        });

        return this.downloadPromise;
    }

    // Prompt user for permission to download
    async promptForPermission(): Promise<boolean> {
        const choice = await vscode.window.showInformationMessage(
            `‚öôÔ∏è Graphics.h Compiler setup required\n\n` +
            `To compile graphics programs, a one-time setup is needed.\n` +
            `üì¶ ~220MB download, ~770MB disk space\n\n` +
            `Download and continue?`,
            { modal: true },
            'Download',
            'Cancel'
        );

        return choice === 'Download';
    }

    // Update download configuration
    updateConfig(config: Partial<DownloadConfig>): void {
        Object.assign(this.MINGW_CONFIG, config);
    }
}

